* Javascript Learning
** Multiline
#+BEGIN_SRC js :cmd "babel-node"
return ```
HEllo
WOrld
abcdefgh
```
#+END_SRC
** Clujure
#+BEGIN_SRC js :cmd "babel-node"
  var digit_name = (function (n) {
      var names;
      return function (n) {
          if (!names){
              names = ['zero', 'one', 'two', 'three','four', 'five','six' ];
          }
          return names[n];
      };
  }());
  console.log(digit_name(6));
#+END_SRC

#+RESULTS:
: six
: undefined

** split words
#+NAME: splitw
#+BEGIN_SRC js :cmd "babel-node" :var a="Test123***  TEST"
    return a.split(" ").reduce(function (max, val) {
        console.log(max + "  " + val);
        return val.length > max ? val.length : max;
    } , 0);
#+END_SRC

#+RESULTS: splitw
: 0  Test123***
: 10
: 10  TEST
: 10

** substring

#+BEGIN_SRC js :cmd "babel-node" :var str="abcdefgh"  :var target="fgh"
return target === str.substr(str.length - target.length, str.length - 1)
#+END_SRC

#+RESULTS:
: true

** multidimen arrary
#+BEGIN_SRC js :cmd "babel-node" :results output
  function largestOfFour(arr) {
    var p=[];
    arr.reduce(function(arrmax, arr1){
        var maxnumberofthearray = arr1.reduce(function(elmmax, elm) {
            return elm > elmmax ? elm: elmmax;
        },0);
        p.push(maxnumberofthearray);
        return 0;
    } , 0);
    return p;
  }

  console.log(largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]));
#+END_SRC

#+RESULTS:
: [ 5, 27, 39, 1001 ]

** filter
*** MAP
#+BEGIN_SRC js :cmd "babel-node" :results output
  var contacts = [
      {
          "firstName": "Akira",
          "lastName": "Laine",
          "number": "0543236543",
          "likes": ["Pizza", "Coding", "Brownie Points"]
      },
      {
          "firstName": "Harry",
          "lastName": "Potter",
          "number": "0994372684",
          "likes": ["Hogwarts", "Magic", "Hagrid"]
      },
      {
          "firstName": "Sherlock",
          "lastName": "Holmes",
          "number": "0487345643",
          "likes": ["Intriguing Cases", "Violin"]
      },
      {
          "firstName": "Kristian",
          "lastName": "Vos",
          "number": "unknown",
          "likes": ["Javascript", "Gaming", "Foxes"]
      }
  ];


  function lookUp(firstName, prop){
  // Only change code below this line
    var directory = contacts.filter(function(address){
      if ( (prop in  address) && address["firstName"] === firstName ){
        return true;
      }
      return false;
    });
    return !directory.length ? "No such contact" : directory[0][prop];

  // Only change code above this line
  }

  // Change these values to test your function
  console.log(lookUp("Akira", "likes"));

#+END_SRC

#+RESULTS:
: [ 'Pizza', 'Coding', 'Brownie Points' ]

** TODO Prototype
#+BEGIN_SRC js :cmd "node-babel"  :results output
  const food = {
      init: function (type) {
          this.type = type;
      },
      eat: function() {
          console.log('you ate the')
      }


#+END_SRC

#+RESULTS:

** Map Reduce
#+BEGIN_SRC js :cmd "babel-node" :results output replace
  function chunk(arr, size) {
    // Break it up.
    return arr.reduce(function(atom,val,index){
        if (index%size === 0){
            atom.push(arr.slice(index,size+index));
        }
        return atom;
    } , [] );
  }

  console.log(chunk(["a", "b", "c", "d"], 2));
#+END_SRC

#+RESULTS:
** char to string
#+BEGIN_SRC js :cmd "babel-node" :results output
  var a = "URYYB".split("").map(function(p){
      return /\s/.test(p) ? p: String.fromCharCode((p.charCodeAt(0)-65 +13)%26 +65);
  });
  console.log( "" + a);
#+END_SRC

#+RESULTS:
: H,E,L,L,O

** string Matching case
#+BEGIN_SRC js :cmd "babel-node" :results output
  function mutation(arr) {
    return arr[1].toLowerCase().split("").filter(function(m){
      return arr[0].toLowerCase().split("").indexOf(m) >= 0;
    }).length === arr[1].length;
/*
.reduce(function(a,b){
      if (a){
        return b >= 0? true: false;
      }
      return false;
    });
*/
  }
  console.log("|" + mutation(["hello", "Hello"]) + "|");
#+END_SRC

#+RESULTS:
: |true|

** Function Argument convert to array
#+BEGIN_SRC js :cmd "babel-node" :resutls output
  function destroyer(arr) {
    // Remove all the values
      var args = Array.prototype.slice.call(arguments, 1);
    return arr.filter(function(v){
        return !args.reduce(function(isthere,val){
            if (isthere === true) return true;
            return  (val === v) ? true : false;
      },false);
    });
  }

console.log(destroyer([1, 2, 3, 1, 2, 3], 2, 3));
#+END_SRC

#+RESULTS:
| 1 | 1 |

** sort
#+BEGIN_SRC js :cmd "babel-node" :resutls output
  function where(arr, num) {
    // Find my place in this sorted array.
    return arr.sort(function(a,b){
      return a > b;
    }).reduce(function(a,pos,index) {
        if ( pos < num )
            return a+1;
        return a;
    },0);
  }
  console.log(where([40, 60], 50));
#+END_SRC

#+RESULTS:
: 1
: undefined
** Sum min to max

#+BEGIN_SRC js :cmd "babel-node" :resutls output
  function sumAll(arr) {
    return [Math.min(arr[0],arr[1]), Math.max(arr[0],arr[1])].reduce(function(sum,b){
        return (b*(b+1))/2 - sum;
    },Math.min(arr[0],arr[1]));
  }

  console.log(sumAll([1, 4]));
#+END_SRC

#+RESULTS:
: 10
: undefined

** diffs

#+BEGIN_SRC js :cmd "babel-node" :resutls  output
  function diff(arr1, arr2) {
      var arr = arr1;
      // Same, same; but different.

      return arr2.filter( function (val) {
          var flag=true;
          arr = arr.reduce(function(diffs,elm){
              if(elm === val){
                  flag = false;
                  return diffs;
              }
              return diffs.concat(elm);
          },[]);
          return flag;
      }).concat(arr);
  }

return  diff(["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"]);

#+END_SRC

#+RESULTS:
| diorite | pink wool |

** Roman Numerial
#+NAME: ruman
#+BEGIN_SRC js :cmd "babel-node" :var num="353"
  var rumannumberrule = function(x,index){
      var rumancombination = [["I","V"],["X","L"],["C","D"]];
      if (x < 4) return rumancombination[index][0].repeat(x);
      if (x === 4) return rumancombination[index].join("");
      if (x < 9 ) return rumancombination[index][1] +  rumancombination[index][0].repeat(x-5);
      return rumancombination[index][0] + rumancombination[index+1][0];
  };

  var numtoarray = function(nm, numarr){
      if (nm === 0) return numarr;
      numarr.unshift(nm%10);
      return numtoarray(Math.floor(nm/10),numarr);
  };

  return numtoarray(num,[]).map(function(val, index,arrl) {
      return rumannumberrule(val,arrl.length - index -1);
  }).join("");
#+END_SRC

#+RESULTS: ruman
: CCCLIII

#+call: ruman(19)

#+RESULTS:
: XIX


#+BEGIN_SRC js :cmd "babel-node" :var r="I"
  var numtoarray = function(nm, numarr){
      if (nm === 0) return numarr;
      numarr.push(nm%10);
      return numtoarray(Math.floor(nm/10),numarr);
  };
  return numtoarray(322, []);
#+END_SRC

#+RESULTS:
| 2 | 2 | 3 |

** Reduce Data to Manipulate
#+BEGIN_SRC sh
npm install -g fs
#+END_SRC

#+RESULTS:
| /usr/local/lib |          |
| └──            | fs@0.0.2 |
|                |          |

#+BEGIN_SRC js :cmd "babel-node"
  let fs = require('fs');
  let output = fs.readFileSync('data.org','utf8')
                 .trim()
                 .split('\n')
                 .map( line => line.split('|').map( word => word.trim() )
                                              .filter(word => word.length))
                 .reduce((customers , line) => {
                     customers[line[0]] = customers[line[0]] || []
                     customers[line[0]].push({
                         name: line[1],
                         price: line[2],
                         quantity: line[3]
                     })
                     return customers
                  }, {})

  console.log('output', JSON.stringify(output, null, 2));
#+END_SRC

#+RESULTS:
#+begin_example
output {
  "mark Johnson": [
    {
      "name": "waffle",
      "price": "iron",
      "quantity": "80"
    },
    {
      "name": "blender",
      "price": "200",
      "quantity": "1"
    },
    {
      "name": "knife",
      "price": "10",
      "quantity": "4"
    }
  ],
  "Nikita Smith": [
    {
      "name": "waffle",
      "price": "iron",
      "quantity": "80"
    },
    {
      "name": "knife",
      "price": "10",
      "quantity": "2"
    },
    {
      "name": "nuts",
      "price": "20",
      "quantity": "3"
    }
  ]
}
undefined
#+end_example
** Curring
#+BEGIN_SRC js :cmd "babel-node"
  let dragons = [
      { name: 'flpikin', element: 'lighting'},
      { name: 'noomi', element: 'lighting'},
      { name: 'kora', element: 'fire'},
      { name: 'doomer', element: 'timewarp'}
  ]

  let hasElement =
      (element, obj) => obj.element === element

  let lightingDragons =
      dragons.filter( x => hasElement('lighting',x))

  console.log(JSON.stringify(lightingDragons,null,2)
#+END_SRC

#+RESULTS:
** Regex
*** reduce to alplanumaric
#+NAME: onlyalphanum
#+BEGIN_SRC js :cmd "babel-node" :var a="Test123***  TEST"
  return a.replace(/[^a-z0-9]/gi,'');
#+END_SRC

#+RESULTS:
: Test123TEST

#+call: onlyalphanum("race car")

#+RESULTS:
: racecar

*** Hello World
#+BEGIN_SRC js :cmd "babel-node"
return "thisIsSpinalTap".replace(/([a-z])([A-Z])/g,"$1-$2")

#+END_SRC

#+RESULTS:
: this-Is-Spinal-Tap

*** Unclassifed
#+BEGIN_SRC js :cmd "babel-node" :resutls output
let re = /\w+\s/g;
let str = "fee fi fo fum";
let myArr = str.match(re);
//console.log( myArr);
console.log(/[a-z]+/.test(str[2]))
#+END_SRC

#+RESULTS:
: true
: undefined

#+BEGIN_SRC js :cmd "babel-node" :resutls output
var myArray = /d(b+)d/g.exec("cdbbbdsbz");
console.log(myArray.index);
#+END_SRC

#+RESULTS:
: 1
: undefined

#+BEGIN_SRC js :cmd "babel-node" :resutls output
  var myRe = new RegExp("\\w+\\s*","g");
  var myArray = "I go    to   school everyday".match(myRe);
  console.log(myArray);
#+END_SRC

#+RESULTS:
| I | go | to | school | everyday |

#+BEGIN_SRC js :cmd "babel-node" :resutls output
let re = /(\w+)\s(\w+)/;
let str = "John Smith";
let newStr = str.replace(re ,"$2, $1");
console.log(newStr);
#+END_SRC

#+RESULTS:
: Smith, John
: undefined

** crypto
#+BEGIN_SRC js :cmd "babel-node" :resutls output
  function translate(str) {
    var suffix="yay";
    var remainder ="";
    var vowelisthere = false;
    return str.split("").map(function(elm,index){
      var vowel={
        "a": true,
        "e": true,
        "i": true,
        "o": true,
        "u": true
      };
      console.log("|" + vowel[elm] + "|" + elm + "|" );
      if (vowel.hasOwnProperty(elm) && vowel[elm] === true){
          vowelisthere = true;
      }
      if (vowelisthere === false){
          remainder = remainder + elm;
          suffix= "ay";
          return "";
      }
      if (index === str.length -1){
        return elm + remainder + suffix;
      }
      return elm;
    }).join("");
  }

  console.log(translate("consonant"));

#+END_SRC

#+RESULTS:
#+begin_example
|undefined|c|
|true|o|
|undefined|n|
|undefined|s|
|true|o|
|undefined|n|
|true|a|
|undefined|n|
|undefined|t|
onsonantcay
undefined
#+end_example

** missing letter
#+BEGIN_SRC js :cmd "babel-node"  :resutls output
  function fearNotLetter(str) {
    var miss = undefined;
    str.split("").reduce(function(missing,b){
        if (b.charCodeAt(0) !== missing && miss === undefined) {
          console.log("|"+b+"|"+missing +"|" + b.charCodeAt(0) + "|");
          miss=String.fromCharCode(missing);
        }
        return missing+1;
    }, str[0].charCodeAt(0));
    return miss;
  }
fearNotLetter("abcdefghjklmno")

#+END_SRC

#+RESULTS:
: |j|105|106|
: undefined

#+BEGIN_SRC js :cmd "babel-node"
return "A".charCodeAt(0)
#+END_SRC

#+RESULTS:
: 65

** Sorted Union
#+BEGIN_SRC js :cmd "babel-node"
      function diff(arr1, arr2) {
          var arr = arr2;
          // Same, same; but different.

          return arr1.filter( function (val) {
              var flag=true;
              arr = arr.reduce(function(diffs,elm){
                  if(elm === val){
                      flag = false;
                      return diffs;
                  }
                  if (typeof elm === "number")
                      return diffs.concat(elm);
                  return diffs.concat([elm])
              },[]);
              return true;
          }).concat(arr);
      }

    function unite(arr1, arr2, arr3) {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function(flat,arr){
            return diff(flat,arr);
        }, []);
    }
  //  return unite([1, 2, 3], [5, 2, 1]);
  return unite([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8])

#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 5 | 4 | 6 | 7 | 8 |
** html sytex change
#+BEGIN_SRC js :cmd "babel-node" :restuls output
    function convert(str) {
      // &colon;&rpar;
        var htmlized = (function() {
            var htmlmap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "\"":  "&quot;",
                "'": "&apos;",
            };
            return function(value) {
                return htmlmap[value];
            }
        }());
      var matched = str.match(/([&<>"'])/g);
      return !matched ? str : matched.reduce(function(st,elm){
          return st.replace(elm, htmlized(elm));
      },str);

    }

var r=convert("abc & bcd");
console.log(r);
#+END_SRC

#+RESULTS:
: abc &amp; bcd
: undefined

#+BEGIN_SRC js :cmd "babel-node" :resutls output
function convert(str){
  return str;
}
var r=convert("Dolce Gabbana Hello");
console.log(r);
#+END_SRC

#+RESULTS:
: Dolce Gabbana Hello
: undefined

** Object
#+BEGIN_SRC js :cmd "babel-node" :resutls output
  function hello(){
      var ar=[3,33,[333]];
      var f = function(arrr) {
          return arrr[2];
      }
      return f(ar).concat(3);
  }
  return hello();
#+END_SRC

#+RESULTS:
| 333 | 3 |

** Sum of All prime
#+BEGIN_SRC js :results output
  function sumPrimes(num) {
    var populate = function (x,isprimes){
      isprimes.push(x);
      if (x === num) return isprimes;
      return populate(x+1);
    };

    var limit = Math.sqrt(num);

    var isprimefun = function(primearr,n){
      if ( primearr[n] > limit){
        return primearr;
      }

      var primearr_1 = primearr.filter(function(elm){
         if (elm%primearr[n])
           return true;
         return false;
        });
      return isprimefun(primearr_1,primearr_1[n+1]);
    };

    return isprimefun(populate(2,[]),1);

  }

  return sumPrimes(10);

#+END_SRC

#+RESULTS:
* Emacs Lisp Cookbook
** Introduction
This page contains snippets of code that demonstrate basic EmacsLisp programming operations in the spirit of the O’Reilly cookbook series of books. For every task addressed, a worked-out
solution is presented as a short, focused, directly usable piece of code.

All this stuff can be found elsewhere, but it is scattered about in libraries, manuals, etc. It would be helpful to have here in one spot.

These recipes should be pastable into the *scratch* buffer so that users can hit ‘C-j’ and evaluate them step by step.

There’s going to be some overlap with CategoryCode, obviously. Just link to more elaborate pages when appropriate. Should this page grow too large, we’ll split it up later.

** Strings

The empty string (zero-length string, null string, …):
#+NAME: abc
#+BEGIN_SRC emacs-lisp
    (zerop (string-match "" "")) ;; O(n)
    (string-equal "" "") ;; O(n)?
    (equal "" "") ;; O(n)?
    (zerop (length "")) ;; O(1)
#+END_SRC

#+RESULTS: abc
: t



As a (very minor) space and performance optimization, starting with Emacs 23, Emacs keeps an interned copy of the empty string as a single object

#+NAME: equal
#+BEGIN_SRC emacs-lisp
    (eq "" "") ;; O(1)
    (eq "" (purecopy ""))
    (eq "" (propertize "" 'face 'italic))

#+END_SRC

** String
#+BEGIN_SRC elisp
    (defun string/ends-with (s ending)
      "Return non-nil if string S ends with ENDING."
      (cond ((>= (length s) (length ending))
             (let ((elength (length ending)))
               (string= (substring s (- 0 elength)) ending)))
            (t nil)))
  (if (string-equal (substring (mapconcat '(lambda (a) a) '("S" " D" "D") "") 0 1) "E")  "A" "D"  )

  (apply #'concat )

  (apply #'concat '("AF" "BHD"))

  (setq test-str "abcdefg  ")
  (when (string-match "[ \t]*$" test-str)
    (message (concat "[" (replace-match "" nil nil test-str ) "]")))

#+END_SRC

** Strings vs buffer text
*** Defination
While it is quite common in other programming languages to work on strings contained in variables, in Emacs it is also common to work on text in buffers.

*** Substrings

#+NAME: substr
#+BEGIN_SRC emacs-lisp
    (substring "abcdefg" 0 3)
#+END_SRC

#+RESULTS: substr
: abc

#+NAME: substr1
#+BEGIN_SRC emacs-lisp
    (substring "abcdefg" -3 -1)
#+END_SRC

#+RESULTS: substr1
: ef

**** The TO argument is optional:
#+NAME: substr2
#+BEGIN_SRC emacs-lisp
     (substring "abcdefg" -3)
#+END_SRC

#+RESULTS: substr2
: efg

*** Buffers
#+NAME: buf1
#+BEGIN_SRC emacs-lisp
    (with-temp-buffer (insert "abcdefg") (buffer-substring 2 4))
#+END_SRC

#+RESULTS: buf1
: bc

** starts-with and ends-with predicates
*** example2
#+NAME: endwith1
#+BEGIN_SRC emacs-lisp
    (defun string/ends-with (s ending)
      "Return non-nil if string S ends with ENDING."
      (cond ((>= (length s) (length ending))
             (let ((elength (length ending)))
               (string= (substring s (- 0 elength)) ending)))
            (t nil)))
#+END_SRC

#+RESULTS: endwith1
: string/ends-with
*** example2-1
#+NAME: beginwith
#+BEGIN_SRC emacs-lisp
    (defun string/starts-with (s begins)
      "Return non-nil if string S starts with BEGINS."
      (cond ((>= (length s) (length begins))
             (string-equal (substring s 0 (length begins)) begins))
            (t nil)))

#+END_SRC

*** Example 2 Faster, simpler
#+NAME: rxendwith
#+BEGIN_SRC emacs-lisp
    (defun string/ends-with (string suffix)
      "Return t if STRING ends with SUFFIX."
      (and (string-match (rx-to-string `(: ,suffix eos) t)
                         string)
           t))

#+END_SRC
*** Example 2 Faster, simpler start with
#+NAME: rxstartwith
#+BEGIN_SRC emacs-lisp
    (defun string/starts-with (string prefix)
      "Return t if STRING starts with prefix."
      (and (string-match (rx-to-string `(: bos ,prefix) t)
                         string)
           t))

#+END_SRC
** Processing characters
** Reversing a string:
#+NAME: stringrev
#+BEGIN_SRC emacs-lisp
    (defun string/reverse (str)
      "Reverse the str where str is a string"
      (apply #'string
	     (reverse
	      (string-to-list str))))
#+END_SRC
** Looking at characters in a temporary buffer:
#+NAME: distance_char
#+BEGIN_SRC emacs-lisp
    (with-temp-buffer
      (insert "abcdefg")
      (goto-char (point-min))
      (while (not (= (char-after) ?b)) (forward-char))
      (point))
#+END_SRC

#+RESULTS: distance_char
: 2
** Trim whitespace
**** Trim whitespace from the end of a string
#+NAME: trimend
#+BEGIN_SRC emacs-lisp
    (setq test-str "abcdefg  ")
    (when (string-match "[ \t]*$" test-str)
      (message (concat "[" (replace-match "" nil nil test-str) "]")))

#+END_SRC
**** Trim whitespace from a string with a Perl-like chomp function
#+NAME: chopperllike
#+BEGIN_SRC emacs-lisp
    (defun chomp (str)
      "Chomp leading and tailing whitespace from STR."
      (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'"
                           str)
        (setq str (replace-match "" t t str)))
      str)

#+END_SRC
**** Let’s not overcomplicate matters
**** defun chomp-end (str)
       Chomp tailing whitespace from STR.
#+NAME: trimend
#+BEGIN_SRC emacs-lisp
      (replace-regexp-in-string (rx (* (any " \t\n")) eos)
                                ""
                                str)
#+END_SRC
**** Chomp leading and tailing whitespace from STR
#+NAME: choplt
#+BEGIN_SRC emacs-lisp :var str="             abc       "
      (replace-regexp-in-string (rx (or (: bos (* (any " \t\n")))
                                        (: (* (any " \t\n")) eos)))
                                ""
                               str)
#+END_SRC

#+RESULTS: choplt
: abc
**** TODO Splitting strings
** Joining strings
**** Use ‘mapconcat’ to join a list of strings using a separator string between them.
- example 1
#+NAME: concat
#+BEGIN_SRC emacs-lisp :var table=table1[0]  :var separator="/"
  (mapconcat 'identity table separator)
#+END_SRC

#+RESULTS: concat
: marry/had/little/lamp

#+name: table1
| marry | had   | little | lamp |
| that  | where | marry  | went |

- If the separator is empty, use ‘apply’:
#+NAME: applyconcat
#+BEGIN_SRC emacs-lisp :var  table=table1[1]
  (apply #'concat table)
#+END_SRC

#+RESULTS: applyconcat
: thatwheremarrywent

    If the separator is empty then ‘concat’ (or ‘format’) is sufficient - no need for ‘apply’ to join the strings: (concat "hello, " "world") ⇒ "hello, world" (If the strings are available
    only as an explicit list, then of course you will want to use ‘apply’ or an equivalent.) – DrewAdams
** Serialization
Convert forms to strings using ‘prin1-to-string’, then convert back from a string using ‘read’.
  (length (read (prin1-to-string (make-list 1000000 '(x)))))

  (read (prin1-to-string "Hello World!"))
    ==> "Hello World!"

This works only in the simplest cases. Unfortunately, it doesn’t work for all EmacsLisp data types.

  (read (prin1-to-string (make-hash-table))) ;; Error before Emacs 23.
    ==> #s(hash-table size 65 test eql rehash-size 1.5 [...] data ())
  (read (prin1-to-string (current-buffer)))
    ==> Lisp error: (invalid-read-syntax "#")
** Formatting
*** Killing text
As the ElispManual says, “Most of the kill commands are primarily for interactive use […] When you need to delete text for internal purposes within a Lisp function, you should normally use
deletion functions, so as not to disturb the kill ring contents.”

The following mimic the ‘kill-’ commands but without disturbing the kill ring. To make them kill, use ‘kill-region’ instead of ‘delete-region’.
*** Delete region

The Lisp equivalent of ‘kill-region’ (‘C-w’) but without kill-ring side effects::

  (delete-region (region-beginning) (region-end))

According to the ElispManual, “Few programs need to use the ‘region-beginning’ and ‘region-end’ functions.” This is because Lisp code should not rely on nor “alter the mark unless altering
the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it
in a Lisp variable. For example: […]”

*** Delete line
The equivalent of ‘kill-line’ (‘C-k’) but without kill-ring side effects:
 (let ((beg (point)))
   (forward-line 1)
   (forward-char -1)
   (delete-region beg (point)))
**** Alternatively, replacing the ‘let’ with ‘progn’.
 (delete-region (point) (progn (forward-line 1)
                               (forward-char -1)
                               (point)))
**** Or just:
(delete-region (point) (line-end-position))

The examples with ‘forward-line’ are shown for comparison with other examples, below.
**** Delete line backwards
The equivalent of killing the line backwards (‘C-0 C-k’) but without kill-ring side effects:
 (let ((beg (point)))
   (forward-line 0)
   (delete-region (point) beg))
**** Alternatively, replacing the ‘let’ with ‘progn’.
 (delete-region (progn (forward-line 0) (point))
                (point))
**** Or just:
(delete-region (line-beginning-position) (point))
*** Delete line to next line
**** The equivalent of killing the line and the newline (‘C-1 C-k’) but without kill-ring side effects:
 (let ((beg (point)))
   (forward-line 1)
   (delete-region beg (point)))
**** Alternatively, replacing the ‘let’ with ‘progn’.
 (delete-region (point) (progn (forward-line 1) (point)))
*** Delete whole line
**** The equivalent of ‘kill-whole-line’ (‘C-S-DEL’) but without kill-ring side effects:

 (let ((beg (progn (forward-line 0)
                   (point))))
   (forward-line 1)
   (delete-region beg (point)))

**** Alternatively, replacing the ‘let’ with ‘progn’.

 (delete-region (progn (forward-line 0) (point))
                (progn (forward-line 1) (point)))

**** Or just:

 (delete-region (line-beginning-position)
                (line-end-position))

*** Delete word
**** The equivalent of ‘kill-word’ (‘M-d’) but without kill-ring side effects:
 (let ((beg (point)))
   (forward-word 1)
   (delete-region beg (point)))
**** Alternatively, replacing the ‘let’ with ‘progn’.

 (delete-region (point) (progn (forward-word 1) (point)))

*** Delete sentence
**** The equivalent of ‘kill-sentence’ (‘M-k’) but without kill-ring side effects:
 (let ((beg (point)))
   (forward-sentence 1)
   (delete-region beg (point)))
**** Alternatively, replacing the ‘let’ with ‘progn’.
 (delete-region (point) (save-excursion
                          (forward-sentence 1)
                          (point)))
*** Numbers
Test whether a string represents a number
#+NAME: stringtointeger
#+BEGIN_SRC emacs-lisp
 (defun string-integer-p (string)
   (if (string-match "\\`[-+]?[0-9]+\\'" string)
       t
     nil))
 (string-integer-p "1234")
#+END_SRC

#+RESULTS: stringtointeger
: t

 (string-integer-p "x1234")
   ==> nil
 (string-integer-p "3.141592653589793")
   ==> nil

 (defun string-float-p (string)
   (if (string-match "\\`[-+]?[0-9]+\\.[0-9]*\\'" string)
       t
     nil))
 (string-float-p "1234")
   ==> nil
 (string-float-p "3.141592653589793")
   ==> t
 (string-float-p ".1")
   ==> nil
 (string-float-p "1.")
   ==> t
*** String to number
The following example is for instruction. Normally standard function ‘string-to-number’ would be used.

#+NAME: decimalnum
#+BEGIN_SRC emacs-lisp
    (defun decimal-number-inv (string)
      (let ((n (string-to-number string)))
        (save-match-data
          (if (and (not (zerop n))
                   (string-match (rx-to-string  `(: (0+ space) (submatch (1+ num) ) (? "." ) (submatch (0+ num) )   (0+ space)  )) string))
              (string-to-number (concat (match-string 2 string) "." (match-string 1 string)))
            nil))))


                                          ;
  ;  (decimal-number "3.141592653589793")
                                          ; (decimal-number "042")
  ;  (decimal-number " 0 ")
  ;  (decimal-number "000")
  ;  (decimal-number "0.0")
#+END_SRC

#+RESULTS: decimalnum
*** Random numbers

 (random 2)  ;coin toss (0 or 1)
 (+ (random 6) 1)  ;dice
*** Put commas in numbers
(group-number 299792458)
#+NAME: group_number
#+BEGIN_SRC emacs-lisp :var  num=""  :var  size="3"  :var  sep=","
  (defun group-number (num &optional size char)
    "Format NUM as string grouped to SIZE with CHAR."
    ;; Based on code for `math-group-float' in calc-ext.el
    (let* ((size (or size 3))
           (char (or char ","))
           (str (if (stringp num)
                    num
                  (number-to-string num)))
            ;; omitting any trailing non-digit chars
            ;; NOTE: Calc supports BASE up to 36 (26 letters and 10 digits ;)
           (pt (or (string-match "[^0-9a-zA-Z]" str) (length str))))
      (while (> pt size)
        (setq str (concat (substring str 0 (- pt size))
                          char
                          (substring str (- pt size)))
              pt (- pt size)))
      str))
  (group-number num size sep)
#+END_SRC
** Increment numbers
See IncrementNumber.
** Dates and times
Today's date
#+NAME: today
#+BEGIN_SRC emacs-lisp
  (defun today-is ()
    "Display current time."
    (interactive)
    (message (format-time-string "Today is %Y-%m-%d %T")))
  (today-is )
#+END_SRC

#+RESULTS: today
: Today is 2016-03-05 22:42:34

See InsertingTodaysDate.
*** Formatting dates
Use the function ‘format-time-string’ which is a build in function in both Emacsen and works like ‘strftime’:

    ;; Year-Month-Day:
#+NAME: date
#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
    (insert (format-time-string "%Y-%m-%d"))
    (buffer-string))
#+END_SRC

#+RESULTS: date
: 2016-03-05

    ;; Hour:Minutes:Seconds
#+NAME: hour
#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
    (insert (format-time-string "%H-%M-%S"))
    (buffer-string))
#+END_SRC

#+RESULTS: hour
: 22-44-53
** Conversions
*** Read a date from a string.
#+NAME: str_date
#+BEGIN_SRC emacs-lisp
  (let ((time (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
    (set-time-zone-rule t) ;; Use Universal time.
    (prog1 (format-time-string "%Y-%m-%d %T UTC" time)
      (set-time-zone-rule nil))) ;; Reset to default time zone.
#+END_SRC

#+RESULTS: str_date
: 1983-09-27 17:35:59 UTC
*** Decode a time object.
 (decode-time (date-to-time "Tue, 27-Sep-83 12:35:59 EST"))
 ==> (59 35 13 27 9 1983 2 t -14400)
*** Get the seconds from the unix epoch.
 (let ((time (date-to-time "13 Feb 2009 23:31:30 UTC")))
   (float-time time))
 ==> 1234585890.0
*** Find the date for seconds from the unix epoch.
 (format-time-string "%Y-%m-%d %T UTC" (seconds-to-time 1234585890))
 ==> "2009-02-13 23:31:30 UTC"
*** Find the date 30 seconds in the future.
 (format-time-string "%Y-%m-%d %T UTC" (time-add (current-time)
                                                 (seconds-to-time 30)))
 ==> "2012-02-13 10:07:11 UTC"
*** Formatting elapsed time in years, days, hours, minutes and seconds.
 (format-seconds "%Y %D %h:%m:%s" (1- (* 367 24 3600)))
 ==> "1 year 1 day 23:59:59"
*** Find the days between two dates.
 (let ((days1 (time-to-days (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
       (days2 (time-to-days (date-to-time "2009-02-13 23:31:30 UTC"))))
   (- days2 days1))
 ==> 9271
*** Getting the day in the year.
 (time-to-day-in-year (current-time))
 ==> 44
*** Build a date based on the day of the year.
 (format-time-string "%j"
                     (encode-time 0 0 0 44 1 2012))
 ==> "044"
** Pattern matching
“Patterns” refers to RegularExpressions.
There’s a set of functions that work in strings, and a set that work in buffers.
*** Finding
#+NAME: pattern_match
#+BEGIN_SRC emacs-lisp
  (string-match "foo*" "Fight foo for food!")
#+END_SRC

#+RESULTS: pattern_match

*** Using a temporary buffer instead:
#+NAME: pattern_match2
#+BEGIN_SRC emacs-lisp
    (with-temp-buffer
      (insert "Fight     foo  for food!")
      (goto-char (point-min))
      (re-search-forward "foo*")
      (point))
#+END_SRC

#+RESULTS: pattern_match2
: 14

Alternative without regular expressions: ‘search-forward’.

The functions working on buffers move point to the end of the occurrence found and return it. That’s why the result is 10 instead of 6.
*** Verifying
Sometimes you just want to check whether you’re at the right place:

#+NAME: lootat
#+BEGIN_SRC emacs-lisp
    (with-temp-buffer
      (insert "Fight foo for food!")
      (goto-char (point-min))
      (looking-at "fight"))
#+END_SRC

#+RESULTS: lootat
: t

*** Search and replace

#+NAME: searchreplace
#+BEGIN_SRC emacs-lisp
  (replace-regexp-in-string "foo*" "fu" "Fight foo for food!")
#+END_SRC

#+RESULTS: searchreplace
: Fight fu fur fud!

*** Using a temporary buffer instead:
#+NAME: replacematch2
#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
     (insert "*** foo for food!\n*** Abcdefg")
     (goto-char (point-min))
     (while (re-search-forward  (rx-to) nil t)
       (replace-match "#***"))
     (buffer-string))
#+END_SRC

#+RESULTS: replacematch2
: Fight fu fur fud!

*** Alternative without regular expressions: ‘search-forward’.
See also StringSearchAndReplace.
*** Search and do something with match
This finds numbers and increments them by one. It depends on ‘decimal-number’ that was defined above. See also IncrementNumber.
#+NAME: numinc
#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
    (insert "A = 32 22434 b=-1d c=333adf")
    (goto-char (point-min))
    (while (re-search-forward (rx-to-string `(: (or num (or "+" "-")))) nil t)
      (goto-char (match-beginning 0))
      (when  (looking-at  (rx-to-string `(: (? (or "+" "-") ) (1+ num)) ) )
        (replace-match
         (number-to-string (+ (string-to-number (match-string 0)) 1)))
        (goto-char (match-end 0)))) (buffer-string))
#+END_SRC

#+RESULTS: numinc
: A = 33 22435 b=0d c=334adf

*** This loads EmacsLisp files listed one per line in a text file.
#+NAME: loadfileselected
#+BEGIN_SRC emacs-lisp
  ;;; hello.el
  ;; (when (file-exists-p filename)
  ;; (load-file filename))
  (let ((files '()))
    (with-current-buffer (find-file-noselect "~/load-file.txt")
      (goto-char  (point-min) )
      (while (re-search-forward (rx-to-string `(:    line-start     (0+ not-newline)  ?.  (or "el" "gz" "tar")   )) nil t)
        (let ((filename (match-string 0)) (list '()))
          (setq flies (cons filename files))))
      (apply #'insert files)(buffer-string) ))
#+END_SRC

#+RESULTS: loadfileselected
: hello.el
: sadf.gz
: adfdsfasdfsd.dsfsd
: dssss.a
: fasdfads.el
: fasdfads.el

*** This loads EmacsLisp files listed one per line in a text file.
#+NAME: filetocmd
#+BEGIN_SRC emacs-lisp
  ;;; hello.el
  ;; (when (file-exists-p filename)
  ;; (load-file filename))
  (let ((files '()))
    (with-current-buffer (find-file-noselect "~/load-file.txt")
      (goto-char  (point-min) )
      (while (re-search-forward (rx-to-string `(:    line-start   (submatch  (0+ not-newline)  ?. (submatch (or "el" "gz" "tar")))    )) nil t)
        (replace-match (concat "#+call(" (match-string 1) ")")))))
#+END_SRC

*** Extracting submatches from a regex match

Like in most other regex implementations, if you use grouping parentheses in a regular expression, you can extract the text that matched each parenthesized group. Groups are numbered from
the opening parenthesis, left to right. These are also called back references, or backrefs, or matching groups.

#+NAME: email
#+BEGIN_SRC emacs-lisp :var email="hello@gmail.com"
  (defun parse-email(email)
    (let ((user "") (domain ""))
      (save-match-data ; is usually a good idea
        (and (string-match "\\`\\([^@]+\\)@\\([^@]+\\)\\'" email)
             (setq user (match-string 1 email)
                   domain (match-string 2 email) ) ))
      (with-temp-buffer
        (insert (concat "user: " user "\n"))
        (insert (concat "domain: " domain  "\n")) (buffer-string))))
(parse-email email)
#+END_SRC

#+RESULTS: email
: user: hello
: domain: gmail.com

Usually you would use *let* instead of *setq* but this is just a simple self-contained example. See also DynamicBindingVsLexicalBinding.
*** Mapping with a regex
This invokes a function at every match of a regexp:
#+NAME: mapregex
#+BEGIN_SRC emacs-lisp :var file="" :var regex="" :var l=""
  (defun map-regex (buffer regex fn)
    "Map the REGEX over the BUFFER executing FN.
    FN is called with the match-data of the regex.
    Returns the results of the FN as a list."
    (with-current-buffer buffer
      (save-excursion
        (goto-char (point-min))
        (let (res)
          (save-match-data
            (while (re-search-forward regex nil t)
              (let ((f (match-data)))
                (setq res
                      (append res
                              (list
                               (save-match-data
                                 (funcall fn f))))))))
          res))))

  ;; "^\\(.*.el\\(\\.gz\\)*\\)$"
  ;; (when (file-exists-p filename)
  ;;   (load-file filename))
  (map-regex
   (find-file-noselect "~/load-file.txt")
   (rx-to-string `(:    line-start     (0+ not-newline)  ?.  (or "el" "gz" "tar")   ))
   (lambda (md)
     (let ((filename (match-string 0)))
       (replace-match (concat "<" filename ">") )
       )))

  (map-regex
   (find-file-noselect "~/load-file.txt")
   (rx-to-string `(:    line-start  (submatch  (0+ not-newline)  ?.  (or "el" "gz" "tar"))   ))
   (lambda (md)
     (let ((filename (match-string 1)))
       (concat   filename "~" )
       )))
#+END_SRC
*** Finding all the strings that match

If you want to list all the matching strings, including subexpressions:

#+NAME: matchStringAll
#+BEGIN_SRC emacs-lisp
  (defun match-strings-all (&optional string)
    "Return the list of all expressions matched in last search.
  STRING is optionally what was given to `string-match'."
    (let ((n-matches (1- (/ (length (match-data)) 2))))
      (mapcar (lambda (i) (match-string i string))
              (number-sequence 0 n-matches))))

  (let ((str "time help"))
    (string-match "time \\([A-Za-z]+\\)$" str)
    (match-strings-all str))
#+END_SRC

#+RESULTS: matchStringAll
| time help | help |

** Code Comments
*** Move to the beginning of the current comment:
  (require 'newcomment)
  (comment-beginning)
*** Move to the text after a comment:
    (comment-search-forward (line-end-position) t)
See also EndOfLineNoComments.
** TODO Sequences
*** Datatypes used to represent sequences of things:

   _____________________________________________
  |                                             |
  |          Sequence                           |
  |  ______   ________________________________  |
  | |      | |                                | |
  | | List | |             Array              | |
  | |      | |    ________       ________     | |
  | |______| |   |        |     |        |    | |
  |          |   | Vector |     | String |    | |
  |          |   |________|     |________|    | |
  |          |  ____________   _____________  | |
  |          | |            | |             | | |
  |          | | Char-table | | Bool-vector | | |
  |          | |____________| |_____________| | |
  |          |________________________________| |
  |_____________________________________________|
*** Lists
List basics are explained at ListStructure. Lists can shrink and grow, but access to elements towards the end of the list is slow if the list is long.
**** Use ‘cons’, ‘push’, or ‘add-to-list’ to prepend a new element to a list. Use ‘nth’ to access an element of a list.

#+NAME: conex1
#+BEGIN_SRC emacs-lisp
    (let ((words '("fight" "foo" "for" "food!")))
      (when (string= "foo" (nth 1 words))
        (setq words (cons "bar" words)))
      words)
#+END_SRC

#+RESULTS: conex1
| bar | fight | foo | for | food! |

See ListModification for more ways of changing a list.
**** Iteration:
#+NAME: iterex1
#+BEGIN_SRC emacs-lisp
    (let ((result  ()))
      (dolist (word  '("fight" "foo" "for" "food!"))
        (when (string-match "o" word) (push word result)))
      (nreverse result))
#+END_SRC

#+RESULTS: iterex1
| (1 2) | (3 4) |
| (1 2) | (5 6) |

Note how ‘push’ adds an element to the front of the list, so that usually the list has to be reversed after the loop. ‘nreverse’ is particularly efficient because it does this destructively.
See DestructiveOperations for more about this.
**** TODO Copying
Use ‘copy-sequence’ to make a shallow copy of a list without changing the original.
#+NAME: iterex1
#+BEGIN_SRC emacs-lisp
    (let* ((orig '((1 2) (3 4)))
           (copy (copy-sequence orig)))
      (setcdr copy '((5 6)))
      (list orig copy))
#+END_SRC
   ==> (((1 2) (3 4)) ((1 2) (5 6)))
**** The elements in the copy remain in the original.
More importantly, they are in fact the same elements (i.e., ‘eq’), not copies.
The list is copied, but its elements are shared with the
original list.
#+NAME: sharedcpy
#+BEGIN_SRC emacs-lisp
    (let* ((orig '((1 2) (3 4)))
           (copy (copy-sequence orig)))
      (setcdr (cadr copy) '(0))
      (list orig copy))
#+END_SRC

#+RESULTS: sharedcpy
| (1 2) | (3 0) |
| (1 2) | (3 0) |

**** ‘copy-tree’ is the recursive version of ‘copy-sequence’.
#+NAME: copytree
#+BEGIN_SRC emacs-lisp
  (let* ((orig '((1 2) (3 4)))
         (copy (copy-tree orig)))
    (setcdr (cadr copy) '(0))
    (list orig copy))
#+END_SRC

#+RESULTS: copytree
| (1 2) | (3 4) |
| (1 2) | (3 0) |

**** Filtering:
A ‘filter’ macro has been added to the Emacs development tree. It does what you expect: filters a list, returning a copy that keeps elements that satisfy a predicate and omitting elements
that do not satisfy it.

If your Emacs does not yet have this built in, you can use ‘dolist’ or ‘mapcar’ to iterate over a list with a conditional, and then use ‘delq’ to remove the ‘nil’ values.

#+NAME: myfilter
#+BEGIN_SRC emacs-lisp
  (defun my-filter (condp lst)
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

    (let ((num-list '(1 'a 2 "nil" 3 nil 4)))
      (my-filter 'numberp num-list))
#+END_SRC

#+RESULTS: myfilter
| 1 | 2 | 3 | 4 |

**** Here is a version of quicksort:

#+NAME: quicksort
#+BEGIN_SRC emacs-lisp
 (defun quicksort (lst)
   "Implement the quicksort algorithm."
   (if (null lst) nil
     (let* ((spl (car lst))
            (rst (cdr lst))
            (smalp (lambda (x)
                  (< x spl))))
       (append (quicksort (remove-if-not smalp rst))
               (list spl)
               (quicksort (remove-if smalp rst))))))
 (quicksort '(5 7 1 3 -9 8 7 -4 0))
#+END_SRC

#+RESULTS: quicksort
| -9 | -4 | 0 | 1 | 3 | 5 | 7 | 7 | 8 |

****  The following function was written by tali713 in response to hypnocat’s question regarding a filter function in #emacs:

#+NAME: hyponocat
#+BEGIN_SRC emacs-lisp
    (defun keep-when (pred seq)
      (let ((del (make-symbol "del")))
        (remove del (mapcar (lambda (el)
			      (if (funcall pred el) el del)) seq))))


  (keep-when 'atom '(1 2 3 (4 5) 6 nil t foo))
#+END_SRC

#+RESULTS: hyponocat
| 1 | 2 | 3 | 6 | nil | t | foo |

  ==> (1 2 3 6 nil t foo)

Updated 31/05/2013.
**** Tranposing:
***** TODO Create a list from multiple lists:

 ((lambda (&rest args)
    (mapcar (lambda (n)
              (delq nil (mapcar (lambda (arg) (nth n arg)) args)))
            (number-sequence 0 (1- (apply 'max (mapcar 'length args))))))
  '(1 2 3) '(a b c) '(A B C))
  ==> ((1 a A) (2 b B) (3 c C))
***** TODO A more concise version is possible with the the higher-arity version of ‘mapcar’ available from library ‘cl’.

  ((lambda (&rest args)
     (apply (function mapcar*) (function list) args))
   '(1 2 3) '(a b c) '(A B C))
  ==> ((1 a A) (2 b B) (3 c C))
**** Searching:

You can check for presence of a value in a list using ‘member’ or ‘memq’.

  (let ((words  '("fight" "foo" "for" "food!")))
    (car (member "for" words)))
  ==> "for"
  (let ((re    "\\wo\\b")
        (words '("fight" "foo" "for" "food!")))
    (consp (memq t
             (mapcar (lambda (s) (numberp (string-match re s))) words))))
  ==> t

In the latter, a more efficient algorithm would use a loop (a non-local exit).
*** Association lists

The ElispManual has examples of finding and deleting values in an association list, or alist. Here are cases when the car values are strings.

#+NAME: acclist
#+BEGIN_SRC emacs-lisp
  (assoc "2" '(("2" . 23) ("1" . 3) ("231") ("3" . 3)))
#+END_SRC

#+RESULTS: acclist
: (2 . 23)


#+NAME: acclisp2
#+BEGIN_SRC emacs-lisp
  (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65))
#+END_SRC

#+RESULTS: acclisp2

  ==> ((56 . "8") (57 . "9") (58 . ":") (59 . ";") (60 . "<")
       (61 . "=") (62 . ">") (63 . "?") (64 . "@") (65 . "A"))
  (assq 64
        (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65)))
  ==> (64 . "@")
  (assq 55
        (mapcar (lambda (c) (cons c (string c))) (number-sequence 56 65)))
  ==> nil

Deleting:

#+NAME: delq
#+BEGIN_SRC emacs-lisp
  (let ((alist '(("a" . 1) ("b" . 2))))
    (delq (assoc "a" alist) alist))
#+END_SRC

#+RESULTS: delq

Matches with a test function other than ‘equal’:

#+NAME: assocdefault
#+BEGIN_SRC emacs-lisp
  (let ((alist '(("ab" . 1) ("bc" . 2) ("cd" . 3))))
    (assoc-default "c" alist (lambda (x y) (string-match y x))))
#+END_SRC

#+RESULTS: assocdefault
: 2

The alist functions are useful for finding the first instance of a value in any list, not just association lists, and even when there are duplicates.

The following uses ‘mapcar’ to associate the ‘major-mode’ to each buffer returned by ‘buffer-list’, then ‘assq’ to find the first buffer where the major mode is ‘fundamental-mode’.

#+NAME: acc3
#+BEGIN_SRC emacs-lisp
  (assq 'fundamental-mode
        (mapcar
         (lambda (b)
           (cons (buffer-local-value 'major-mode b) b))
         (buffer-list)))
#+END_SRC

#+RESULTS: acc3
: (fundamental-mode . *About GNU Emacs*)


You can also find values in regular lists, by converting them to association lists with a null cdr.

Here’s an association list of random numbers with no associated value.

#+NAME: randomnil
#+BEGIN_SRC emacs-lisp
  '((8 . nil) (3 . nil) (1 . nil) (7 . nil) (3 . nil) (6 . nil) (9 . nil))
#+END_SRC

#+RESULTS: randomnil
| 8 |
| 3 |
| 1 |
| 7 |
| 3 |
| 6 |
| 9 |


This is really just making a list for each number – a “list of lists” – which can be done with ‘mapcar’ and ‘list’.

#+NAME: listoflistassq
#+BEGIN_SRC emacs-lisp
  (mapcar 'list '(8 3 1 7 3 6 9))
  (assq 3 (mapcar 'list '(8 3 1 7 3 6 9)))
#+END_SRC

#+RESULTS: listoflistassq
| 3 |

*** Vectors

Vectors are fixed in size, and their elements can be accessed in constant time (neither of which is the case for lists).

#+NAME: vector2
#+BEGIN_SRC emacs-lisp
    (let ((words ["fight" "foo" "for" "food!"]))
      (when (string= "foo" (aref words 1))
        (aset words 1 "bar"))
      words)
#+END_SRC

#+RESULTS: vector2
: ["fight" "bar" "for" "food!"]


**** Convert vector to list

All vectors are sequences and the map functions work on sequences, so:

#+NAME: veclist
#+BEGIN_SRC emacs-lisp
(mapcar 'identity [1 2 3 4])
#+END_SRC

#+RESULTS: veclist
| 1 | 2 | 3 | 4 |

  ==> (1 2 3 4)

Here is another Lisp idiom for the same thing:

#+NAME: veclist3
#+BEGIN_SRC emacs-lisp
(append [1 2 3 4] ())
#+END_SRC

#+RESULTS: veclist3
| 1 | 2 | 3 | 4 |

***  Hash tables

Hash tables map keys to values. They are similar to alists, but they are typically more efficient for a large number of keys.

See HashMap.

Storing and retrieving keys and values

By default, hash tables use ‘eql’ to compare keys. This is not appropriate for strings: (eql "alex" "alex") ⇒ nil. Use ‘equal’ in such cases:

#+NAME: hashmap
#+BEGIN_SRC emacs-lisp
    (let ((nick-table (make-hash-table :test 'equal)))
      (puthash "kensanata" "Alex Schroeder" nick-table)
      (gethash "kensanata" nick-table))
#+END_SRC

#+RESULTS: hashmap
: Alex Schroeder

**** Iterate:

#+NAME: iteratehash
#+BEGIN_SRC emacs-lisp
    (let ((nick-table (make-hash-table :test 'equal))
          nicks)
      (puthash "kensanata" "Alex Schroeder" nick-table)
      (puthash "e1f" "Luis Fernandes" nick-table)
      (puthash "pjb" "Pascal J. Bourguignon" nick-table)
      (maphash (lambda (nick real-name)
                 (setq nicks (cons nick nicks)))
               nick-table)
      nicks)
#+END_SRC

#+RESULTS: iteratehash
| pjb | e1f | kensanata |

**** Sorting keys

Use ‘maphash’ to build up a list of keys, sort it, and then loop through the list:

#+NAME: hashmapsort
#+BEGIN_SRC emacs-lisp
    (let ((nick-table (make-hash-table :test 'equal))
          nicks)
      (puthash "kensanata" "Alex Schroeder" nick-table)
      (puthash "e1f" "Luis Fernandes" nick-table)
      (puthash "pjb" "Pascal J. Bourguignon" nick-table)
      (maphash (lambda (nick real-name)
                 (setq nicks (cons nick nicks)))
               nick-table)
      (mapcar (lambda (nick)
                (concat nick " => " (gethash nick nick-table)))
              (sort nicks 'string<)))
#+END_SRC

#+RESULTS: hashmapsort
| e1f => Luis Fernandes | kensanata => Alex Schroeder | pjb => Pascal J. Bourguignon |

** Files
*** Read
A file can be inserted at point with ‘insert-file-contents’ or ‘insert-file-contents-literally’. To get a file as a string,

  (defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))

On the chance that a buffer may already be actively visiting the file, consider using ‘find-file-noselect’

  (defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-current-buffer (find-file-noselect file)
      (buffer-string)))
*** TODO Filter

Processing a file is usually done with a temporary buffer:

 (defun process-file (file, lmda)
   "Read the contents of a file into a temp buffer and then do
 something there."
   (when (file-readable-p file)
     (with-temp-buffer
       (insert-file-contents file)
       (goto-char (point-min))
       (while (not (eobp))
         ;; do something here with buffer content

         (forward-line)))))
*** Write

To write something to a file you can create a temporary buffer, insert the things to write there and write the buffer contents to a file. The following example read a string and a filename
(with completion, but doesn’t need to exist, see InteractiveCodeChar F) and write the string to that file.

 (defun write-string-to-file (string file)
   (interactive "sEnter the string: \nFFile to save to: ")
   (with-temp-buffer
     (insert string)
     (when (file-writable-p file)
       (write-region (point-min)
                     (point-max)
                     file))))

Another way to do this is via with-temp-file:

 (defun write-string-to-file (string file)
   (interactive "sEnter the string: \nFFile to save to: ")
   (with-temp-file file
     (insert string)))
*** Input and output (I/O)

This is a nice and simple way to edit a file with Emacs Lisp, especially when there’s a chance the file might be already be visited in Emacs and its ok to edit the existing buffer.

  (with-current-buffer (find-file-noselect "~/logfile")
    (goto-char (point-max))
    (insert (format "Hash of last line: %s"
             (md5
              (save-excursion
                (forward-line -1)
                (buffer-substring-no-properties (point)
                                                (line-end-position))))))
    (newline)
    (with-temp-message "Writing file..."
      (save-buffer))
    (message "Writing file...done"))
*** Searching within a File

If you don’t have grep, then you may need to write some Lisp which can find a match in a file.

  ;; Visit file unless its already open.
  (with-current-buffer (find-file-noselect "~/.emacs")
    (save-excursion ;; Don't change location of point.
      (goto-char (point-min)) ;; From the beginning...
      (if (re-search-forward ".*load-path.*" nil t 1)
          (match-string-no-properties 0)
        (error "Search failed"))))
  ==> "(add-to-list 'load-path \"/usr/share/emacs/site-lisp/\")"
*** Locking

  (unless (file-locked-p (buffer-file-name))
     (lock-buffer))
*** Stat

An interface to the kernel’s stat(2) is provided by the function file-attributes.

    (let* ((attrs (file-attributes (buffer-file-name)))
           (atime (nth 4 attrs))
           (mtime (nth 5 attrs))
           (ctime (nth 6 attrs)))
      (concat "File last accessed on "
              (format-time-string "%Y-%m-%d %T" atime) "\n"
              "File last modified on "
              (format-time-string "%Y-%m-%d %T" mtime) "\n"
              "File last changed on "
              (format-time-string "%Y-%m-%d %T" ctime) "\n"))
*** Deleting

  (if (file-exists-p filename)
      (delete-file filename))

Copy, move and rename

  (copy-file file new-name)
  (rename-file file new-dir)
  (rename-file file new-name)
** Directories
*** Listing

All files in a directory sorted by name:

  (directory-files "~/")
  ==> ("." ".." ".bash_history" ".bashrc" ".emacs" ".emacs.d" "diary" "local" "public_html")
*** File names matching a regular expression and in no particular order.

 (directory-files "~/" (not 'absolute) "\\`\\." 'nosort)
 ==> (".emacs.d" ".emacs" ".bash_history" ".bashrc" ".." ".")
*** File names matching a wildcard expression sorted by name.

 (let ((default-directory "~/"))
   (file-expand-wildcards "?emacs*"))
 ==> (".emacs" ".emacs.d")
*** All files sorted by modification time:

 (let ((default-directory "~/"))
   (sort
     (directory-files default-directory (not 'absolute) nil 'nosort)
     (lambda (a b)
       (time-less-p (nth 5 (file-attributes a))
                    (nth 5 (file-attributes b))))))
 ==> (".bashrc" "diary" "public_html" "local" ".bash_history" ".." ".emacs" ".emacs.d" ".")
** Recursion

Here’s an example of using ‘directory-files’ to find all subdirectories in a subdirectory.

Could potentially surpass ‘max-lisp-eval-depth’ if the filesystem has a suffienctly complex number of subdirectories.

  (defun directory-dirs (dir)
    "Find all directories in DIR."
    (unless (file-directory-p dir)
      (error "Not a directory `%s'" dir))
    (let ((dir (directory-file-name dir))
          (dirs '())
          (files (directory-files dir nil nil t)))
        (dolist (file files)
          (unless (member file '("." ".."))
            (let ((file (concat (file-name-as-directory dir) file)))
              (when (file-directory-p file)
                (setq dirs (append (cons file
                                         (directory-dirs file))
                                   dirs))))))
        dirs))
** Giving ‘directory-dirs’ an absolute file name:

  (directory-dirs "/emacs/lisp")
  ==> ("/usr/share/emacs/23.2/lisp/calc" "/usr/share/emacs/23.2/lisp/calendar"
       "/usr/share/emacs/23.2/lisp/cedet" "/usr/share/emacs/23.2/lisp/cedet/ede" ...)

Setting the ‘default-directory’ to a directory allows ‘directory-dirs’ to return relative file names for subdirectories.

  (let ((default-directory "/usr/share/emacs/23.2/lisp"))
    (directory-dirs "."))
  ==> ("./calc" "./calendar" "./cedet" "./cedet/ede" ...)
** Traversing

A file-tree-walk function has been added to the Emacs development tree. Until it lands in your version, you can use this:

    (defun walk-path (dir action)
       "walk DIR executing ACTION with (dir file)"
       (cond ((file-directory-p dir)
              (or (char-equal ?/ (aref dir(1- (length dir))))
                  (setq dir (file-name-as-directory dir)))
              (let ((lst (directory-files dir nil nil t))
                     fullname file)
                (while lst
                  (setq file (car lst))
                  (setq lst (cdr lst))
                  (cond ((member file '("." "..")))
                        (t
                         (and (funcall action dir file)
                              (setq fullname (concat dir file))
                              (file-directory-p fullname)
                              (walk-path fullname action)))))))
             (t
              (funcall action
                       (file-name-directory dir)
                       (file-name-nondirectory dir)))))
    (defun walk-path-visitor (dir file)
       "Called by walk-path for each file found"
       (message (concat  dir file)))
    (walk-path "~/" 'walk-path-visitor)
** Path splitting

Splitting the path can be done with ‘split-string’ and with the slash. Previously, Emacs would determine the character separating directory names with ‘directory-sep-char’. However, the
variable is obselete with Emacs 21.1.

  (split-string default-directory "/")
  ==> ("" "usr" "share" "emacs" "22.2" "lisp" "")

For splitting a path variable, Emacs already has the ‘parse-colon-path’ function.

  (parse-colon-path (getenv "PATH"))
  ==> ("/usr/lib/qt-3.3/bin/" "/usr/kerberos/bin/" "/usr/local/bin/" "/usr/bin/" "/bin/" "/usr/local/sbin/" "/usr/sbin/" "/sbin/")
** Processes

Running a program

Run a command without caring about its output.

  (async-shell-command "emacs")

Run a command and put its output in the current buffer.

  (shell-command "seq 8 12 | sort" t)
  10
  11
  12
  8
  9

Run a command and put its output in a new buffer.

  (shell-command "seq 8 12 | sort"
                 (get-buffer-create "*Standard output*"))

Run a command return its output as a string.

  (shell-command-to-string "seq 8 12 | sort")

Run a command return and insert its output at point in the current buffer.

  (insert (shell-command-to-string "date"))

Handling signals
** Sockets

Tcp client

Tcp server

Perhaps EmacsEchoServer and EmacsDaytimeServer can be useful here. Also Edit with Emacs' edit-server.el which is a more complete server implementation.

Keyboard events

Call function bound to key

  (funcall (key-binding (kbd "M-TAB")))

or

  (call-interactively (key-binding (kbd "M-TAB")))
** Test code

Sometimes you might want to insert some demonstration code in a module. The code should not be run when the module is loaded via ‘require’ or ‘load’ but when you ‘eval-current-buffer’. All
you need to do add is add a test condition of ‘eval-buffer-list’:

  (dont-compile
    (when (eq (car eval-buffer-list) (current-buffer))
      ...))
** Misc Lisp
*** Elisp Cookbook
**** String
#+BEGIN_SRC elisp
(zerop (string-match "" ""))
(string-equal "A" "A")
(equal "AAA" "AAA")
(zerop (length "  "))
(length "  ")
(eq ""  "")
(eq "" (purecopy ""))
(eq "" (propertize "" 'face 'italic))
#+END_SRC

#+RESULTS:
: t

**** tutorial
#+BEGIN_SRC emacs-lisp
;;; test.el starts here

(defun ev(n) (if (= (% n 2) 0) "even" "odd"))
;;; C-u C-M-x C-u C-M-x
(defun hello(name)
  (let ((name (upcase name))) (message "Hello, %s!" name)))
(defun pick-a-word (n)
  (cond
   ((= n 1) "one")
   ((= n 2) "two")
   (t "hello")))

(defun factorial (n)
  (if (< n 1) 1 (* n (factorial (- n 1)) )))

(defun qs (list)
  (if (null list)
      '()
    (let* (pivot (car list))
      (rest (cdr list))
      (lesser (remove-if-not
               (lambda (x) (<= x pivot)) rest ))
      (greater (remove-if-not (lambda (x) (> x pivot) ) rest))
      (append (qs lesser) '( pivot) (qs greater))
      )))
(global-set-key (kbd "M-e") 'sort-lines)

(add-hook 'c-mode-common-hook (lambda () (local-set-key (kbd '<f5>) 'recompile)))
(defun insertlinebefor ()
  "insert line before"
  (interactive)
  (save-excursion (move-beginning-of-line 1)(newline)))
(global-set-key (kbd "C-S-m") 'insertlinebefor)

#+END_SRC
**** String vs Buffer txt
***** Substring
#+BEGIN_SRC elisp
  (substring "abcdefg" 0 3)
  (substring "abcdefg" -3 -1)
  (with-temp-buffer (insert "abcdefg")
                    (buffer-substring 2 4))
#+END_SRC
***** Start-with and ends-with predicates
#+BEGIN_SRC elisp
    (defun string/ends-with (s ending)
      " Return non-nil if string S ends with ENDING."
      (cond ((>= (length s)  (length ending))
             (let ((elength (length ending)))
               (string= (substring s (- 0 elength)) ending)))
            (t nil)))
    (string/ends-with "hello" "ll")
    (defun string/starts-with (s begins)
      "Return non-nil if string S starts with BEGINS."
      (cond ((>= (length s) (length begins))
             (string-equal (substring s 0  (length begins)) begins))
            (t nil)))
        (string/starts-with "ABC" "A")
      (defun string/ends-withmac (string suffix)
      "Return t if STRING ends with SUFFIX."
      (and (string-match (rx-to-string `(: ,suffix eos) t) string) t))
      (string/ends-withmac "hello" "llo")

    (defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t) string) t))
#+END_SRC
***** Processing characters
#+BEGIN_SRC elisp
  (defun string/reverse (str)
    "Reverse the str where str is a string"
    (apply #'string (reverse (string-to-list str))))
(string/reverse "hello World")
#+END_SRC
***** Looking at characters in a temporary buffer
#+BEGIN_SRC elisp
  (with-temp-buffer
    (insert "abcdefg")
    (goto-char (point-min))
    (while (not (= (char-after) ?b)) (forward-char)) (point))
#+END_SRC
***** Trim whitespace
#+BEGIN_SRC elisp
(setq test-str "abcdefg   ")
(when (string-match "[ \t]*$" test-str)
(message (concat "[" (replace-match "ABC" nil nil test-str) "]")))
#+END_SRC
*** Test
#+BEGIN_SRC elisp
;;; test.el starts here

(defun ev(n) (if (= (% n 2) 0) "even" "odd"))
;;; C-u C-M-x C-u C-M-x
(defun hello(name)
  (let ((name (upcase name))) (message "Hello, %s!" name)))
(defun pick-a-word (n)
  (cond
   ((= n 1) "one")
   ((= n 2) "two")
   (t "hello")))

(defun factorial (n)
  (if (< n 1) 1 (* n (factorial (- n 1)) )))

(defun qs (list)
  (if (null list)
      '()
    (let* (pivot (car list))
      (rest (cdr list))
      (lesser (remove-if-not
               (lambda (x) (<= x pivot)) rest ))
      (greater (remove-if-not (lambda (x) (> x pivot) ) rest))
      (append (qs lesser) '( pivot) (qs greater))
      )))
(global-set-key (kbd "M-e") 'sort-lines)

(add-hook 'c-mode-common-hook (lambda () (local-set-key (kbd '<f5>) 'recompile)))
(defun insertlinebefor ()
  "insert line before"
  (interactive)
  (save-excursion (move-beginning-of-line 1)(newline)))
(global-set-key (kbd "C-S-m") 'insertlinebefor)

#+END_SRC
*** find file
#+BEGIN_SRC elisp
(defun gtd ()
  (interactive)
  (find-file "~/org/gtd.org")
  )
#+END_SRC

#+RESULTS:
: gtd

*** For troubled network auto save frequently
#+BEGIN_SRC elisp
(setq auto-save-interval 1
          auto-save-timeout 1)
#+END_SRC

#+RESULTS:
: 1

**** Automatically save your changes after an customizable interval
I really like this idea, because it’s dumb to make me hit C-x C-s all the time because of technical details of the computer’s architecture, and almost everything I edit is under version control anyway. I like using auto-save-hook, and that seems to work well, but I want to save all the buffers, because if I switch away from a buffer before it autosaves, I want it to get saved when things next get saved after that. So I combined parts of the two above solutions (this is the first elisp code I’ve written, could have glaring problems)
#+BEGIN_SRC elisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
    (dolist (buf (buffer-list))
      (set-buffer buf)
      (if (and (buffer-file-name) (buffer-modified-p))
          (basic-save-buffer)))))
(add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
*** Keyboard Macro [8/9]                                              :MACRO:
         - [X] f3 start
         - [X] f4 end
         - [X] c-x e - execute
         - [X] c-x c-k SPC - debug
         - [X] c-x c-k n - name exp name: abc_mac
         - [X] in .emacs.d - insert-kbd-macro abc_mac
         - [X] repeat infinate c-u 0 c-x e
         - [X] recent commands c-x c-k l
*** Line Truncate                                                  :TRUNCATE:
**** Elisp Command
Note: Need to reset Emacs to get truncate effect
or use [[Command]] directly
#+BEGIN_SRC elisp
(setq-default truncate-lines nil)
#+END_SRC
#+RESULTS:
**** Command
*****  M-x set-variable truncate-lines nil.
*** How can I set a deadline on TODO for the last weekday of the month
#+BEGIN_SRC elisp
(defun last-working-day-deadline ()
  (interactive)
  (let* ((date (calendar-current-date))
  (day (calendar-extract-day date))
  (month (calendar-extract-month date))
  (year (calendar-extract-year date))
  (lastday (calendar-last-day-of-month month year)))
  ;; workdays have "names" of 1 2 3 4 or 5
  (while (not (memq (calendar-day-of-week (list month lastday year)) '(1 2 3 4 5)))
  (decf lastday))
 (org-deadline nil (format "%s-%s-%s" year month lastday))))
#+END_SRC
*** show the Org-mode agenda on Emacs start-up
(add-hook 'after-init-hook 'org-agenda-list)
** TODO KBD
#+NAME: kbd
#+BEGIN_EXAMPLE
  (defun devops-keybindings ()
    (let ((devops-key-map (current-local-map)))
      (local-unset-key (kbd "<f9>"))
      (define-key devops-key-map (kbd "<f9>") 'devops-wrapper)
      ))
  (add-hook 'org-mode-hook 'devops-keybindings)

#+END_EXAMPLE

#+call: cmdaync(kbd)
